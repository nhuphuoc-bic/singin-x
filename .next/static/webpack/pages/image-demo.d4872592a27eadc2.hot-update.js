"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/image-demo",{

/***/ "./contexts/ImageCacheContext.tsx":
/*!****************************************!*\
  !*** ./contexts/ImageCacheContext.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageCacheProvider: function() { return /* binding */ ImageCacheProvider; },\n/* harmony export */   useImageCache: function() { return /* binding */ useImageCache; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/indexedDB */ \"./utils/indexedDB.ts\");\n/* harmony import */ var _utils_mockImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/mockImage */ \"./utils/mockImage.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst ImageCacheContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst ImageCacheProvider = (param)=>{\n    let { children, maxCacheSize = 50, cacheExpiryMs = 5 * 60 * 1000 // 5 minutes\n     } = param;\n    _s();\n    const [cache, setCache] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Map());\n    const pendingRequests = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const cacheRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Keep cacheRef in sync with cache state\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        cacheRef.current = cache;\n    }, [\n        cache\n    ]);\n    const cleanupExpiredItems = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        const now = Date.now();\n        setCache((prevCache)=>{\n            const newCache = new Map(prevCache);\n            const entries = Array.from(newCache.entries());\n            for (const [key, item] of entries){\n                if (now - item.timestamp > cacheExpiryMs) {\n                    URL.revokeObjectURL(item.objectUrl);\n                    newCache.delete(key);\n                }\n            }\n            return newCache;\n        });\n        // Also cleanup IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cleanupExpired(cacheExpiryMs);\n        } catch (error) {\n            console.warn(\"Failed to cleanup IndexedDB:\", error);\n        }\n    }, [\n        cacheExpiryMs\n    ]);\n    const getImage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (imageId)=>{\n        // Check if we have a cached version using ref to avoid dependency\n        const cachedItem = cacheRef.current.get(imageId);\n        if (cachedItem) {\n            const now = Date.now();\n            if (now - cachedItem.timestamp < cacheExpiryMs) {\n                return cachedItem.objectUrl;\n            } else {\n                // Remove expired item\n                URL.revokeObjectURL(cachedItem.objectUrl);\n                setCache((prev)=>{\n                    const newCache = new Map(prev);\n                    newCache.delete(imageId);\n                    return newCache;\n                });\n            }\n        }\n        // Check if there's already a pending request for this imageId\n        const pendingRequest = pendingRequests.current.get(imageId);\n        if (pendingRequest) {\n            return pendingRequest;\n        }\n        // Create new request\n        const requestPromise = (async ()=>{\n            try {\n                // First, try to get from IndexedDB\n                const dbCachedImage = await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getImage(imageId);\n                if (dbCachedImage) {\n                    const now = Date.now();\n                    if (now - dbCachedImage.timestamp < cacheExpiryMs) {\n                        // Create object URL from IndexedDB blob\n                        const objectUrl = URL.createObjectURL(dbCachedImage.blob);\n                        // Add to memory cache\n                        setCache((prev)=>{\n                            const newCache = new Map(prev);\n                            newCache.set(imageId, {\n                                blob: dbCachedImage.blob,\n                                objectUrl,\n                                timestamp: dbCachedImage.timestamp\n                            });\n                            return newCache;\n                        });\n                        return objectUrl;\n                    } else {\n                        // Remove expired item from IndexedDB\n                        await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].removeImage(imageId);\n                    }\n                }\n                // If not in IndexedDB or expired, fetch from API\n                console.log(\"fetching image\", imageId);\n                const requestTimestamp = Date.now();\n                // Retry logic for network issues\n                let lastError;\n                for(let attempt = 1; attempt <= 3; attempt++){\n                    try {\n                        console.log(\"Attempt \".concat(attempt, \" to fetch image\"));\n                        const response = await fetch(\"http://localhost:3008/public/me/ekyc/image/\".concat(imageId, \"?t=\").concat(requestTimestamp), {\n                            method: \"GET\",\n                            headers: {\n                                \"Accept\": \"image/*\",\n                                \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n                                \"Pragma\": \"no-cache\",\n                                \"Expires\": \"0\"\n                            }\n                        });\n                        console.log(\"Response status:\", response.status, response.statusText);\n                        console.log(\"Response headers:\", Object.fromEntries(response.headers.entries()));\n                        // Check if response is actually an image\n                        const contentType = response.headers.get(\"content-type\");\n                        console.log(\"Content-Type:\", contentType);\n                        if (!contentType || !contentType.startsWith(\"image/\")) {\n                            console.warn(\"Response is not an image, content-type:\", contentType);\n                            // Try to read as text to see what we actually got\n                            const textResponse = await response.text();\n                            console.error(\"Response body (first 200 chars):\", textResponse.substring(0, 200));\n                            throw new Error(\"Server returned non-image content: \".concat(contentType));\n                        }\n                        if (!response.ok) {\n                            // If backend is not available, try to create a mock image for testing\n                            if (response.status === 404 || response.status === 400) {\n                                console.log(\"Backend returned error, creating mock image for testing\");\n                                const mockBlob = await (0,_utils_mockImage__WEBPACK_IMPORTED_MODULE_3__.createMockImage)(400, 300, \"Mock: \".concat(imageId));\n                                const objectUrl = URL.createObjectURL(mockBlob);\n                                const timestamp = Date.now();\n                                // Add to memory cache\n                                setCache((prev)=>{\n                                    const newCache = new Map(prev);\n                                    newCache.set(imageId, {\n                                        blob: mockBlob,\n                                        objectUrl,\n                                        timestamp\n                                    });\n                                    return newCache;\n                                });\n                                return objectUrl;\n                            }\n                            throw new Error(\"Failed to load image: \".concat(response.status, \" \").concat(response.statusText));\n                        }\n                        const blob = await response.blob();\n                        console.log(\"Blob created:\", {\n                            size: blob.size,\n                            type: blob.type\n                        });\n                        // Validate that we have a valid image blob\n                        if (!blob.type.startsWith(\"image/\")) {\n                            console.warn(\"Blob is not an image type:\", blob.type);\n                            throw new Error(\"Invalid image type: \".concat(blob.type));\n                        }\n                        if (blob.size === 0) {\n                            console.warn(\"Blob is empty\");\n                            throw new Error(\"Empty image data\");\n                        }\n                        // Test if blob can be read as image\n                        try {\n                            const testUrl = URL.createObjectURL(blob);\n                            const testImg = new Image();\n                            await new Promise((resolve, reject)=>{\n                                testImg.onload = ()=>{\n                                    console.log(\"Blob validation successful:\", {\n                                        width: testImg.width,\n                                        height: testImg.height\n                                    });\n                                    URL.revokeObjectURL(testUrl);\n                                    resolve(true);\n                                };\n                                testImg.onerror = ()=>{\n                                    console.error(\"Blob validation failed - not a valid image\");\n                                    URL.revokeObjectURL(testUrl);\n                                    reject(new Error(\"Blob is not a valid image\"));\n                                };\n                                testImg.src = testUrl;\n                            });\n                        } catch (error) {\n                            console.error(\"Blob validation error:\", error);\n                            throw new Error(\"Invalid image data from server\");\n                        }\n                        const objectUrl = URL.createObjectURL(blob);\n                        console.log(\"Object URL created:\", objectUrl);\n                        const timestamp = Date.now();\n                        // Add to memory cache\n                        setCache((prev)=>{\n                            const newCache = new Map(prev);\n                            // Remove oldest items if cache is full\n                            if (newCache.size >= maxCacheSize) {\n                                const oldestKey = newCache.keys().next().value;\n                                const oldestItem = newCache.get(oldestKey);\n                                if (oldestItem) {\n                                    URL.revokeObjectURL(oldestItem.objectUrl);\n                                    newCache.delete(oldestKey);\n                                }\n                            }\n                            newCache.set(imageId, {\n                                blob,\n                                objectUrl,\n                                timestamp\n                            });\n                            return newCache;\n                        });\n                        // Also save to IndexedDB for persistence\n                        try {\n                            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setImage(imageId, blob, timestamp);\n                        } catch (error) {\n                            console.warn(\"Failed to save to IndexedDB:\", error);\n                        }\n                        return objectUrl;\n                    } catch (error) {\n                        lastError = error;\n                        console.warn(\"Attempt \".concat(attempt, \" failed:\"), error.message);\n                        if (attempt < 3) {\n                            // Wait before retry\n                            await new Promise((resolve)=>setTimeout(resolve, 1000 * attempt));\n                        }\n                    }\n                }\n                // All attempts failed\n                console.error(\"All fetch attempts failed:\", lastError);\n                throw lastError;\n            } finally{\n                // Remove from pending requests\n                pendingRequests.current.delete(imageId);\n            }\n        })();\n        // Store pending request\n        pendingRequests.current.set(imageId, requestPromise);\n        return requestPromise;\n    }, [\n        cacheExpiryMs,\n        maxCacheSize\n    ]); // Removed cache from dependencies\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        // Clean up all object URLs\n        const items = Array.from(cache.values());\n        for (const item of items){\n            URL.revokeObjectURL(item.objectUrl);\n        }\n        setCache(new Map());\n        // Also clear pending requests\n        pendingRequests.current.clear();\n        // Clear IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clearAll();\n        } catch (error) {\n            console.warn(\"Failed to clear IndexedDB:\", error);\n        }\n    }, []); // Removed cache dependency\n    const removeFromCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (imageId)=>{\n        const item = cache.get(imageId);\n        if (item) {\n            URL.revokeObjectURL(item.objectUrl);\n            setCache((prev)=>{\n                const newCache = new Map(prev);\n                newCache.delete(imageId);\n                return newCache;\n            });\n        }\n        // Also remove from IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].removeImage(imageId);\n        } catch (error) {\n            console.warn(\"Failed to remove from IndexedDB:\", error);\n        }\n    }, []); // Removed cache dependency\n    const getCacheStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        try {\n            return await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getCacheStats();\n        } catch (error) {\n            console.warn(\"Failed to get cache stats:\", error);\n            return {\n                count: 0,\n                totalSize: 0\n            };\n        }\n    }, []);\n    // Cleanup expired items periodically\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        const interval = setInterval(cleanupExpiredItems, 60000); // Check every minute\n        return ()=>clearInterval(interval);\n    }, [\n        cleanupExpiredItems\n    ]);\n    // Cleanup on unmount\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        return ()=>{\n            clearCache();\n        };\n    }, [\n        clearCache\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ImageCacheContext.Provider, {\n        value: {\n            getImage,\n            clearCache,\n            removeFromCache,\n            getCacheStats\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/nhuphuoc/Workspace/Tool/signinx/contexts/ImageCacheContext.tsx\",\n        lineNumber: 336,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ImageCacheProvider, \"WS6kNzq6/7ID0g6n+QFjWVIYGMw=\");\n_c = ImageCacheProvider;\nconst useImageCache = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ImageCacheContext);\n    if (!context) {\n        throw new Error(\"useImageCache must be used within an ImageCacheProvider\");\n    }\n    return context;\n};\n_s1(useImageCache, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ImageCacheProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RyxRQUFRO1FBQUNqQixPQUFPO1lBQUVoRDtZQUFVcUQ7WUFBWUs7WUFBaUJDO1FBQWM7a0JBQ3ZGeEY7Ozs7OztBQUdQLEVBQUU7R0ExVFdEO0tBQUFBO0FBNFROLE1BQU1nRyxnQkFBZ0I7O0lBQzNCLE1BQU1DLFVBQVV4RyxpREFBVUEsQ0FBQ007SUFDM0IsSUFBSSxDQUFDa0csU0FBUztRQUNaLE1BQU0sSUFBSXRDLE1BQU07SUFDbEI7SUFDQSxPQUFPc0M7QUFDVCxFQUFFO0lBTldEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbnRleHRzL0ltYWdlQ2FjaGVDb250ZXh0LnRzeD9iZWRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBpbWFnZUNhY2hlREIgZnJvbSAnLi4vdXRpbHMvaW5kZXhlZERCJztcbmltcG9ydCB7IGNyZWF0ZU1vY2tJbWFnZSB9IGZyb20gJy4uL3V0aWxzL21vY2tJbWFnZSc7XG5cbmludGVyZmFjZSBJbWFnZUNhY2hlSXRlbSB7XG4gIGJsb2I6IEJsb2I7XG4gIG9iamVjdFVybDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEltYWdlQ2FjaGVDb250ZXh0VHlwZSB7XG4gIGdldEltYWdlOiAoaW1hZ2VJZDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIGNsZWFyQ2FjaGU6ICgpID0+IHZvaWQ7XG4gIHJlbW92ZUZyb21DYWNoZTogKGltYWdlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgZ2V0Q2FjaGVTdGF0czogKCkgPT4gUHJvbWlzZTx7IGNvdW50OiBudW1iZXI7IHRvdGFsU2l6ZTogbnVtYmVyIH0+O1xufVxuXG5jb25zdCBJbWFnZUNhY2hlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8SW1hZ2VDYWNoZUNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG5cbmludGVyZmFjZSBJbWFnZUNhY2hlUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1heENhY2hlU2l6ZT86IG51bWJlcjtcbiAgY2FjaGVFeHBpcnlNcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IEltYWdlQ2FjaGVQcm92aWRlcjogUmVhY3QuRkM8SW1hZ2VDYWNoZVByb3ZpZGVyUHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIG1heENhY2hlU2l6ZSA9IDUwLFxuICBjYWNoZUV4cGlyeU1zID0gNSAqIDYwICogMTAwMCAvLyA1IG1pbnV0ZXNcbn0pID0+IHtcbiAgY29uc3QgW2NhY2hlLCBzZXRDYWNoZV0gPSB1c2VTdGF0ZTxNYXA8c3RyaW5nLCBJbWFnZUNhY2hlSXRlbT4+KG5ldyBNYXAoKSk7XG4gIGNvbnN0IHBlbmRpbmdSZXF1ZXN0cyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBQcm9taXNlPHN0cmluZz4+PihuZXcgTWFwKCkpO1xuICBjb25zdCBjYWNoZVJlZiA9IHVzZVJlZjxNYXA8c3RyaW5nLCBJbWFnZUNhY2hlSXRlbT4+KG5ldyBNYXAoKSk7XG5cbiAgLy8gS2VlcCBjYWNoZVJlZiBpbiBzeW5jIHdpdGggY2FjaGUgc3RhdGVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWNoZVJlZi5jdXJyZW50ID0gY2FjaGU7XG4gIH0sIFtjYWNoZV0pO1xuXG4gIGNvbnN0IGNsZWFudXBFeHBpcmVkSXRlbXMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBzZXRDYWNoZShwcmV2Q2FjaGUgPT4ge1xuICAgICAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgTWFwKHByZXZDYWNoZSk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbShuZXdDYWNoZS5lbnRyaWVzKCkpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChub3cgLSBpdGVtLnRpbWVzdGFtcCA+IGNhY2hlRXhwaXJ5TXMpIHtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGl0ZW0ub2JqZWN0VXJsKTtcbiAgICAgICAgICBuZXdDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0NhY2hlO1xuICAgIH0pO1xuXG4gICAgLy8gQWxzbyBjbGVhbnVwIEluZGV4ZWREQlxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBpbWFnZUNhY2hlREIuY2xlYW51cEV4cGlyZWQoY2FjaGVFeHBpcnlNcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNsZWFudXAgSW5kZXhlZERCOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtjYWNoZUV4cGlyeU1zXSk7XG5cbiAgY29uc3QgZ2V0SW1hZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAoaW1hZ2VJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgY2FjaGVkIHZlcnNpb24gdXNpbmcgcmVmIHRvIGF2b2lkIGRlcGVuZGVuY3lcbiAgICBjb25zdCBjYWNoZWRJdGVtID0gY2FjaGVSZWYuY3VycmVudC5nZXQoaW1hZ2VJZCk7XG4gICAgaWYgKGNhY2hlZEl0ZW0pIHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAobm93IC0gY2FjaGVkSXRlbS50aW1lc3RhbXAgPCBjYWNoZUV4cGlyeU1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRJdGVtLm9iamVjdFVybDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbW92ZSBleHBpcmVkIGl0ZW1cbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChjYWNoZWRJdGVtLm9iamVjdFVybCk7XG4gICAgICAgIHNldENhY2hlKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gbmV3IE1hcChwcmV2KTtcbiAgICAgICAgICBuZXdDYWNoZS5kZWxldGUoaW1hZ2VJZCk7XG4gICAgICAgICAgcmV0dXJuIG5ld0NhY2hlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFscmVhZHkgYSBwZW5kaW5nIHJlcXVlc3QgZm9yIHRoaXMgaW1hZ2VJZFxuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3RzLmN1cnJlbnQuZ2V0KGltYWdlSWQpO1xuICAgIGlmIChwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgcmVxdWVzdFxuICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcnN0LCB0cnkgdG8gZ2V0IGZyb20gSW5kZXhlZERCXG4gICAgICAgIGNvbnN0IGRiQ2FjaGVkSW1hZ2UgPSBhd2FpdCBpbWFnZUNhY2hlREIuZ2V0SW1hZ2UoaW1hZ2VJZCk7XG4gICAgICAgIGlmIChkYkNhY2hlZEltYWdlKSB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBpZiAobm93IC0gZGJDYWNoZWRJbWFnZS50aW1lc3RhbXAgPCBjYWNoZUV4cGlyeU1zKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgb2JqZWN0IFVSTCBmcm9tIEluZGV4ZWREQiBibG9iXG4gICAgICAgICAgICBjb25zdCBvYmplY3RVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGRiQ2FjaGVkSW1hZ2UuYmxvYik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCB0byBtZW1vcnkgY2FjaGVcbiAgICAgICAgICAgIHNldENhY2hlKHByZXYgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBNYXAocHJldik7XG4gICAgICAgICAgICAgIG5ld0NhY2hlLnNldChpbWFnZUlkLCB7XG4gICAgICAgICAgICAgICAgYmxvYjogZGJDYWNoZWRJbWFnZS5ibG9iLFxuICAgICAgICAgICAgICAgIG9iamVjdFVybCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRiQ2FjaGVkSW1hZ2UudGltZXN0YW1wXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FjaGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFVybDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGV4cGlyZWQgaXRlbSBmcm9tIEluZGV4ZWREQlxuICAgICAgICAgICAgYXdhaXQgaW1hZ2VDYWNoZURCLnJlbW92ZUltYWdlKGltYWdlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vdCBpbiBJbmRleGVkREIgb3IgZXhwaXJlZCwgZmV0Y2ggZnJvbSBBUElcbiAgICAgICAgY29uc29sZS5sb2coJ2ZldGNoaW5nIGltYWdlJywgaW1hZ2VJZCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmV0cnkgbG9naWMgZm9yIG5ldHdvcmsgaXNzdWVzXG4gICAgICAgIGxldCBsYXN0RXJyb3I7XG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IDM7IGF0dGVtcHQrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdCAke2F0dGVtcHR9IHRvIGZldGNoIGltYWdlYCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjMwMDgvcHVibGljL21lL2VreWMvaW1hZ2UvJHtpbWFnZUlkfT90PSR7cmVxdWVzdFRpbWVzdGFtcH1gLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQWNjZXB0JzogJ2ltYWdlLyonLFxuICAgICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby1zdG9yZSwgbXVzdC1yZXZhbGlkYXRlJyxcbiAgICAgICAgICAgICAgICAnUHJhZ21hJzogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgICAgICAnRXhwaXJlcyc6ICcwJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBoZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZXNwb25zZSBpcyBhY3R1YWxseSBhbiBpbWFnZVxuICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ29udGVudC1UeXBlOicsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFjb250ZW50VHlwZSB8fCAhY29udGVudFR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdSZXNwb25zZSBpcyBub3QgYW4gaW1hZ2UsIGNvbnRlbnQtdHlwZTonLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgIC8vIFRyeSB0byByZWFkIGFzIHRleHQgdG8gc2VlIHdoYXQgd2UgYWN0dWFsbHkgZ290XG4gICAgICAgICAgICAgIGNvbnN0IHRleHRSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUmVzcG9uc2UgYm9keSAoZmlyc3QgMjAwIGNoYXJzKTonLCB0ZXh0UmVzcG9uc2Uuc3Vic3RyaW5nKDAsIDIwMCkpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXR1cm5lZCBub24taW1hZ2UgY29udGVudDogJHtjb250ZW50VHlwZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAvLyBJZiBiYWNrZW5kIGlzIG5vdCBhdmFpbGFibGUsIHRyeSB0byBjcmVhdGUgYSBtb2NrIGltYWdlIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCB8fCByZXNwb25zZS5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCYWNrZW5kIHJldHVybmVkIGVycm9yLCBjcmVhdGluZyBtb2NrIGltYWdlIGZvciB0ZXN0aW5nJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9ja0Jsb2IgPSBhd2FpdCBjcmVhdGVNb2NrSW1hZ2UoNDAwLCAzMDAsIGBNb2NrOiAke2ltYWdlSWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0VXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChtb2NrQmxvYik7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gbWVtb3J5IGNhY2hlXG4gICAgICAgICAgICAgICAgc2V0Q2FjaGUocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBNYXAocHJldik7XG4gICAgICAgICAgICAgICAgICBuZXdDYWNoZS5zZXQoaW1hZ2VJZCwge1xuICAgICAgICAgICAgICAgICAgICBibG9iOiBtb2NrQmxvYixcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0VXJsLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0NhY2hlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdFVybDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGltYWdlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Jsb2IgY3JlYXRlZDonLCB7XG4gICAgICAgICAgICAgIHNpemU6IGJsb2Iuc2l6ZSxcbiAgICAgICAgICAgICAgdHlwZTogYmxvYi50eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgaW1hZ2UgYmxvYlxuICAgICAgICAgICAgaWYgKCFibG9iLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdCbG9iIGlzIG5vdCBhbiBpbWFnZSB0eXBlOicsIGJsb2IudHlwZSk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbWFnZSB0eXBlOiAke2Jsb2IudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGJsb2Iuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Jsb2IgaXMgZW1wdHknKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBpbWFnZSBkYXRhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRlc3QgaWYgYmxvYiBjYW4gYmUgcmVhZCBhcyBpbWFnZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgdGVzdFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgIGNvbnN0IHRlc3RJbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRlc3RJbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Jsb2IgdmFsaWRhdGlvbiBzdWNjZXNzZnVsOicsIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRlc3RJbWcud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGVzdEltZy5oZWlnaHRcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0ZXN0VXJsKTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0ZXN0SW1nLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdCbG9iIHZhbGlkYXRpb24gZmFpbGVkIC0gbm90IGEgdmFsaWQgaW1hZ2UnKTtcbiAgICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGVzdFVybCk7XG4gICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdCbG9iIGlzIG5vdCBhIHZhbGlkIGltYWdlJykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGVzdEltZy5zcmMgPSB0ZXN0VXJsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Jsb2IgdmFsaWRhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbWFnZSBkYXRhIGZyb20gc2VydmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnT2JqZWN0IFVSTCBjcmVhdGVkOicsIG9iamVjdFVybCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdG8gbWVtb3J5IGNhY2hlXG4gICAgICAgICAgICBzZXRDYWNoZShwcmV2ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgTWFwKHByZXYpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZGVzdCBpdGVtcyBpZiBjYWNoZSBpcyBmdWxsXG4gICAgICAgICAgICAgIGlmIChuZXdDYWNoZS5zaXplID49IG1heENhY2hlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZGVzdEtleSA9IG5ld0NhY2hlLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkZXN0SXRlbSA9IG5ld0NhY2hlLmdldChvbGRlc3RLZXkpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRlc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZGVzdEl0ZW0ub2JqZWN0VXJsKTtcbiAgICAgICAgICAgICAgICAgIG5ld0NhY2hlLmRlbGV0ZShvbGRlc3RLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgbmV3Q2FjaGUuc2V0KGltYWdlSWQsIHtcbiAgICAgICAgICAgICAgICBibG9iLFxuICAgICAgICAgICAgICAgIG9iamVjdFVybCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FjaGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWxzbyBzYXZlIHRvIEluZGV4ZWREQiBmb3IgcGVyc2lzdGVuY2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IGltYWdlQ2FjaGVEQi5zZXRJbWFnZShpbWFnZUlkLCBibG9iLCB0aW1lc3RhbXApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc2F2ZSB0byBJbmRleGVkREI6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0VXJsO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQXR0ZW1wdCAke2F0dGVtcHR9IGZhaWxlZDpgLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCAzKSB7XG4gICAgICAgICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5XG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwICogYXR0ZW1wdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWxsIGF0dGVtcHRzIGZhaWxlZFxuICAgICAgICBjb25zb2xlLmVycm9yKCdBbGwgZmV0Y2ggYXR0ZW1wdHMgZmFpbGVkOicsIGxhc3RFcnJvcik7XG4gICAgICAgIHRocm93IGxhc3RFcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgcGVuZGluZ1JlcXVlc3RzLmN1cnJlbnQuZGVsZXRlKGltYWdlSWQpO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICAvLyBTdG9yZSBwZW5kaW5nIHJlcXVlc3RcbiAgICBwZW5kaW5nUmVxdWVzdHMuY3VycmVudC5zZXQoaW1hZ2VJZCwgcmVxdWVzdFByb21pc2UpO1xuICAgIFxuICAgIHJldHVybiByZXF1ZXN0UHJvbWlzZTtcbiAgfSwgW2NhY2hlRXhwaXJ5TXMsIG1heENhY2hlU2l6ZV0pOyAvLyBSZW1vdmVkIGNhY2hlIGZyb20gZGVwZW5kZW5jaWVzXG5cbiAgY29uc3QgY2xlYXJDYWNoZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAvLyBDbGVhbiB1cCBhbGwgb2JqZWN0IFVSTHNcbiAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20oY2FjaGUudmFsdWVzKCkpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChpdGVtLm9iamVjdFVybCk7XG4gICAgfVxuICAgIHNldENhY2hlKG5ldyBNYXAoKSk7XG4gICAgLy8gQWxzbyBjbGVhciBwZW5kaW5nIHJlcXVlc3RzXG4gICAgcGVuZGluZ1JlcXVlc3RzLmN1cnJlbnQuY2xlYXIoKTtcblxuICAgIC8vIENsZWFyIEluZGV4ZWREQlxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBpbWFnZUNhY2hlREIuY2xlYXJBbGwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY2xlYXIgSW5kZXhlZERCOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gUmVtb3ZlZCBjYWNoZSBkZXBlbmRlbmN5XG5cbiAgY29uc3QgcmVtb3ZlRnJvbUNhY2hlID0gdXNlQ2FsbGJhY2soYXN5bmMgKGltYWdlSWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBjYWNoZS5nZXQoaW1hZ2VJZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaXRlbS5vYmplY3RVcmwpO1xuICAgICAgc2V0Q2FjaGUocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0NhY2hlID0gbmV3IE1hcChwcmV2KTtcbiAgICAgICAgbmV3Q2FjaGUuZGVsZXRlKGltYWdlSWQpO1xuICAgICAgICByZXR1cm4gbmV3Q2FjaGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBbHNvIHJlbW92ZSBmcm9tIEluZGV4ZWREQlxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBpbWFnZUNhY2hlREIucmVtb3ZlSW1hZ2UoaW1hZ2VJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlbW92ZSBmcm9tIEluZGV4ZWREQjonLCBlcnJvcik7XG4gICAgfVxuICB9LCBbXSk7IC8vIFJlbW92ZWQgY2FjaGUgZGVwZW5kZW5jeVxuXG4gIGNvbnN0IGdldENhY2hlU3RhdHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBpbWFnZUNhY2hlREIuZ2V0Q2FjaGVTdGF0cygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBnZXQgY2FjaGUgc3RhdHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgY291bnQ6IDAsIHRvdGFsU2l6ZTogMCB9O1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIENsZWFudXAgZXhwaXJlZCBpdGVtcyBwZXJpb2RpY2FsbHlcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKGNsZWFudXBFeHBpcmVkSXRlbXMsIDYwMDAwKTsgLy8gQ2hlY2sgZXZlcnkgbWludXRlXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9LCBbY2xlYW51cEV4cGlyZWRJdGVtc10pO1xuXG4gIC8vIENsZWFudXAgb24gdW5tb3VudFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhckNhY2hlKCk7XG4gICAgfTtcbiAgfSwgW2NsZWFyQ2FjaGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbWFnZUNhY2hlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17eyBnZXRJbWFnZSwgY2xlYXJDYWNoZSwgcmVtb3ZlRnJvbUNhY2hlLCBnZXRDYWNoZVN0YXRzIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvSW1hZ2VDYWNoZUNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgdXNlSW1hZ2VDYWNoZSA9ICgpOiBJbWFnZUNhY2hlQ29udGV4dFR5cGUgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJbWFnZUNhY2hlQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlSW1hZ2VDYWNoZSBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEltYWdlQ2FjaGVQcm92aWRlcicpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTsgIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwiaW1hZ2VDYWNoZURCIiwiY3JlYXRlTW9ja0ltYWdlIiwiSW1hZ2VDYWNoZUNvbnRleHQiLCJJbWFnZUNhY2hlUHJvdmlkZXIiLCJjaGlsZHJlbiIsIm1heENhY2hlU2l6ZSIsImNhY2hlRXhwaXJ5TXMiLCJjYWNoZSIsInNldENhY2hlIiwiTWFwIiwicGVuZGluZ1JlcXVlc3RzIiwiY2FjaGVSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiY2xlYW51cEV4cGlyZWRJdGVtcyIsIm5vdyIsIkRhdGUiLCJwcmV2Q2FjaGUiLCJuZXdDYWNoZSIsImVudHJpZXMiLCJBcnJheSIsImZyb20iLCJrZXkiLCJpdGVtIiwidGltZXN0YW1wIiwiVVJMIiwicmV2b2tlT2JqZWN0VVJMIiwib2JqZWN0VXJsIiwiZGVsZXRlIiwiY2xlYW51cEV4cGlyZWQiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0SW1hZ2UiLCJpbWFnZUlkIiwiY2FjaGVkSXRlbSIsImdldCIsInByZXYiLCJwZW5kaW5nUmVxdWVzdCIsInJlcXVlc3RQcm9taXNlIiwiZGJDYWNoZWRJbWFnZSIsImNyZWF0ZU9iamVjdFVSTCIsImJsb2IiLCJzZXQiLCJyZW1vdmVJbWFnZSIsImxvZyIsInJlcXVlc3RUaW1lc3RhbXAiLCJsYXN0RXJyb3IiLCJhdHRlbXB0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJjb250ZW50VHlwZSIsInN0YXJ0c1dpdGgiLCJ0ZXh0UmVzcG9uc2UiLCJ0ZXh0Iiwic3Vic3RyaW5nIiwiRXJyb3IiLCJvayIsIm1vY2tCbG9iIiwic2l6ZSIsInR5cGUiLCJ0ZXN0VXJsIiwidGVzdEltZyIsIkltYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbmxvYWQiLCJ3aWR0aCIsImhlaWdodCIsIm9uZXJyb3IiLCJzcmMiLCJvbGRlc3RLZXkiLCJrZXlzIiwibmV4dCIsInZhbHVlIiwib2xkZXN0SXRlbSIsInNldEltYWdlIiwibWVzc2FnZSIsInNldFRpbWVvdXQiLCJjbGVhckNhY2hlIiwiaXRlbXMiLCJ2YWx1ZXMiLCJjbGVhciIsImNsZWFyQWxsIiwicmVtb3ZlRnJvbUNhY2hlIiwiZ2V0Q2FjaGVTdGF0cyIsImNvdW50IiwidG90YWxTaXplIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJQcm92aWRlciIsInVzZUltYWdlQ2FjaGUiLCJjb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./contexts/ImageCacheContext.tsx\n"));

/***/ })

});