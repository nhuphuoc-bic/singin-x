"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/image-demo",{

/***/ "./contexts/ImageCacheContext.tsx":
/*!****************************************!*\
  !*** ./contexts/ImageCacheContext.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageCacheProvider: function() { return /* binding */ ImageCacheProvider; },\n/* harmony export */   useImageCache: function() { return /* binding */ useImageCache; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/indexedDB */ \"./utils/indexedDB.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst ImageCacheContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst ImageCacheProvider = (param)=>{\n    let { children, maxCacheSize = 50, cacheExpiryMs = 5 * 60 * 1000 // 5 minutes\n     } = param;\n    _s();\n    const [cache, setCache] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Map());\n    const pendingRequests = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const cacheRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Keep cacheRef in sync with cache state\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        cacheRef.current = cache;\n    }, [\n        cache\n    ]);\n    const cleanupExpiredItems = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        const now = Date.now();\n        setCache((prevCache)=>{\n            const newCache = new Map(prevCache);\n            const entries = Array.from(newCache.entries());\n            for (const [key, item] of entries){\n                if (now - item.timestamp > cacheExpiryMs) {\n                    URL.revokeObjectURL(item.objectUrl);\n                    newCache.delete(key);\n                }\n            }\n            return newCache;\n        });\n        // Also cleanup IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cleanupExpired(cacheExpiryMs);\n        } catch (error) {\n            console.warn(\"Failed to cleanup IndexedDB:\", error);\n        }\n    }, [\n        cacheExpiryMs\n    ]);\n    const getImage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (imageId)=>{\n        // Check if we have a cached version using ref to avoid dependency\n        const cachedItem = cacheRef.current.get(imageId);\n        if (cachedItem) {\n            const now = Date.now();\n            if (now - cachedItem.timestamp < cacheExpiryMs) {\n                return cachedItem.objectUrl;\n            } else {\n                // Remove expired item\n                URL.revokeObjectURL(cachedItem.objectUrl);\n                setCache((prev)=>{\n                    const newCache = new Map(prev);\n                    newCache.delete(imageId);\n                    return newCache;\n                });\n            }\n        }\n        // Check if there's already a pending request for this imageId\n        const pendingRequest = pendingRequests.current.get(imageId);\n        if (pendingRequest) {\n            return pendingRequest;\n        }\n        // Create new request\n        const requestPromise = (async ()=>{\n            try {\n                // First, try to get from IndexedDB\n                const dbCachedImage = await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getImage(imageId);\n                if (dbCachedImage) {\n                    const now = Date.now();\n                    if (now - dbCachedImage.timestamp < cacheExpiryMs) {\n                        // Create object URL from IndexedDB blob\n                        const objectUrl = URL.createObjectURL(dbCachedImage.blob);\n                        // Add to memory cache\n                        setCache((prev)=>{\n                            const newCache = new Map(prev);\n                            newCache.set(imageId, {\n                                blob: dbCachedImage.blob,\n                                objectUrl,\n                                timestamp: dbCachedImage.timestamp\n                            });\n                            return newCache;\n                        });\n                        return objectUrl;\n                    } else {\n                        // Remove expired item from IndexedDB\n                        await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].removeImage(imageId);\n                    }\n                }\n                // If not in IndexedDB or expired, fetch from API\n                console.log(\"fetching image\", imageId);\n                const response = await fetch(\"http://localhost:3008/public/me/ekyc/image/\".concat(imageId), {\n                    method: \"GET\",\n                    headers: {\n                        \"Accept\": \"image/*\"\n                    }\n                });\n                console.log(\"Response status:\", response.status, response.statusText);\n                console.log(\"Response headers:\", Object.fromEntries(response.headers.entries()));\n                if (!response.ok) {\n                    // If backend is not available, try to create a mock image for testing\n                    if (response.status === 404 || response.status === 400) {\n                        console.log(\"Backend returned error, creating mock image for testing\");\n                        const mockBlob = await createMockImage(400, 300, \"Mock: \".concat(imageId));\n                        const objectUrl = URL.createObjectURL(mockBlob);\n                        const timestamp = Date.now();\n                        // Add to memory cache\n                        setCache((prev)=>{\n                            const newCache = new Map(prev);\n                            newCache.set(imageId, {\n                                blob: mockBlob,\n                                objectUrl,\n                                timestamp\n                            });\n                            return newCache;\n                        });\n                        return objectUrl;\n                    }\n                    throw new Error(\"Failed to load image: \".concat(response.status, \" \").concat(response.statusText));\n                }\n                const blob = await response.blob();\n                const objectUrl = URL.createObjectURL(blob);\n                const timestamp = Date.now();\n                // Add to memory cache\n                setCache((prev)=>{\n                    const newCache = new Map(prev);\n                    // Remove oldest items if cache is full\n                    if (newCache.size >= maxCacheSize) {\n                        const oldestKey = newCache.keys().next().value;\n                        const oldestItem = newCache.get(oldestKey);\n                        if (oldestItem) {\n                            URL.revokeObjectURL(oldestItem.objectUrl);\n                            newCache.delete(oldestKey);\n                        }\n                    }\n                    newCache.set(imageId, {\n                        blob,\n                        objectUrl,\n                        timestamp\n                    });\n                    return newCache;\n                });\n                // Also save to IndexedDB for persistence\n                try {\n                    await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setImage(imageId, blob, timestamp);\n                } catch (error) {\n                    console.warn(\"Failed to save to IndexedDB:\", error);\n                }\n                return objectUrl;\n            } finally{\n                // Remove from pending requests\n                pendingRequests.current.delete(imageId);\n            }\n        })();\n        // Store pending request\n        pendingRequests.current.set(imageId, requestPromise);\n        return requestPromise;\n    }, [\n        cacheExpiryMs,\n        maxCacheSize\n    ]); // Removed cache from dependencies\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        // Clean up all object URLs\n        const items = Array.from(cache.values());\n        for (const item of items){\n            URL.revokeObjectURL(item.objectUrl);\n        }\n        setCache(new Map());\n        // Also clear pending requests\n        pendingRequests.current.clear();\n        // Clear IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clearAll();\n        } catch (error) {\n            console.warn(\"Failed to clear IndexedDB:\", error);\n        }\n    }, []); // Removed cache dependency\n    const removeFromCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (imageId)=>{\n        const item = cache.get(imageId);\n        if (item) {\n            URL.revokeObjectURL(item.objectUrl);\n            setCache((prev)=>{\n                const newCache = new Map(prev);\n                newCache.delete(imageId);\n                return newCache;\n            });\n        }\n        // Also remove from IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].removeImage(imageId);\n        } catch (error) {\n            console.warn(\"Failed to remove from IndexedDB:\", error);\n        }\n    }, []); // Removed cache dependency\n    const getCacheStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        try {\n            return await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getCacheStats();\n        } catch (error) {\n            console.warn(\"Failed to get cache stats:\", error);\n            return {\n                count: 0,\n                totalSize: 0\n            };\n        }\n    }, []);\n    // Cleanup expired items periodically\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        const interval = setInterval(cleanupExpiredItems, 60000); // Check every minute\n        return ()=>clearInterval(interval);\n    }, [\n        cleanupExpiredItems\n    ]);\n    // Cleanup on unmount\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        return ()=>{\n            clearCache();\n        };\n    }, [\n        clearCache\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ImageCacheContext.Provider, {\n        value: {\n            getImage,\n            clearCache,\n            removeFromCache,\n            getCacheStats\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/nhuphuoc/Workspace/Tool/signinx/contexts/ImageCacheContext.tsx\",\n        lineNumber: 257,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ImageCacheProvider, \"WS6kNzq6/7ID0g6n+QFjWVIYGMw=\");\n_c = ImageCacheProvider;\nconst useImageCache = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ImageCacheContext);\n    if (!context) {\n        throw new Error(\"useImageCache must be used within an ImageCacheProvider\");\n    }\n    return context;\n};\n_s1(useImageCache, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ImageCacheProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eEIscUJBQXFCO0lBQ3JCbkIsc0RBQWUsQ0FBQztRQUNkLE9BQU87WUFDTHNFO1FBQ0Y7SUFDRixHQUFHO1FBQUNBO0tBQVc7SUFFZixxQkFDRSw4REFBQy9ELGtCQUFrQjJFLFFBQVE7UUFBQ2YsT0FBTztZQUFFN0I7WUFBVWdDO1lBQVlLO1lBQWlCQztRQUFjO2tCQUN2Rm5FOzs7Ozs7QUFHUCxFQUFFO0dBNU9XRDtLQUFBQTtBQThPTixNQUFNMkUsZ0JBQWdCOztJQUMzQixNQUFNQyxVQUFVbEYsaURBQVVBLENBQUNLO0lBQzNCLElBQUksQ0FBQzZFLFNBQVM7UUFDWixNQUFNLElBQUl0QixNQUFNO0lBQ2xCO0lBQ0EsT0FBT3NCO0FBQ1QsRUFBRTtJQU5XRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb250ZXh0cy9JbWFnZUNhY2hlQ29udGV4dC50c3g/YmVkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgaW1hZ2VDYWNoZURCIGZyb20gJy4uL3V0aWxzL2luZGV4ZWREQic7XG5cbmludGVyZmFjZSBJbWFnZUNhY2hlSXRlbSB7XG4gIGJsb2I6IEJsb2I7XG4gIG9iamVjdFVybDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEltYWdlQ2FjaGVDb250ZXh0VHlwZSB7XG4gIGdldEltYWdlOiAoaW1hZ2VJZDogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIGNsZWFyQ2FjaGU6ICgpID0+IHZvaWQ7XG4gIHJlbW92ZUZyb21DYWNoZTogKGltYWdlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgZ2V0Q2FjaGVTdGF0czogKCkgPT4gUHJvbWlzZTx7IGNvdW50OiBudW1iZXI7IHRvdGFsU2l6ZTogbnVtYmVyIH0+O1xufVxuXG5jb25zdCBJbWFnZUNhY2hlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8SW1hZ2VDYWNoZUNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XG5cbmludGVyZmFjZSBJbWFnZUNhY2hlUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1heENhY2hlU2l6ZT86IG51bWJlcjtcbiAgY2FjaGVFeHBpcnlNcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IEltYWdlQ2FjaGVQcm92aWRlcjogUmVhY3QuRkM8SW1hZ2VDYWNoZVByb3ZpZGVyUHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIG1heENhY2hlU2l6ZSA9IDUwLFxuICBjYWNoZUV4cGlyeU1zID0gNSAqIDYwICogMTAwMCAvLyA1IG1pbnV0ZXNcbn0pID0+IHtcbiAgY29uc3QgW2NhY2hlLCBzZXRDYWNoZV0gPSB1c2VTdGF0ZTxNYXA8c3RyaW5nLCBJbWFnZUNhY2hlSXRlbT4+KG5ldyBNYXAoKSk7XG4gIGNvbnN0IHBlbmRpbmdSZXF1ZXN0cyA9IHVzZVJlZjxNYXA8c3RyaW5nLCBQcm9taXNlPHN0cmluZz4+PihuZXcgTWFwKCkpO1xuICBjb25zdCBjYWNoZVJlZiA9IHVzZVJlZjxNYXA8c3RyaW5nLCBJbWFnZUNhY2hlSXRlbT4+KG5ldyBNYXAoKSk7XG5cbiAgLy8gS2VlcCBjYWNoZVJlZiBpbiBzeW5jIHdpdGggY2FjaGUgc3RhdGVcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWNoZVJlZi5jdXJyZW50ID0gY2FjaGU7XG4gIH0sIFtjYWNoZV0pO1xuXG4gIGNvbnN0IGNsZWFudXBFeHBpcmVkSXRlbXMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBzZXRDYWNoZShwcmV2Q2FjaGUgPT4ge1xuICAgICAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgTWFwKHByZXZDYWNoZSk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbShuZXdDYWNoZS5lbnRyaWVzKCkpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChub3cgLSBpdGVtLnRpbWVzdGFtcCA+IGNhY2hlRXhwaXJ5TXMpIHtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGl0ZW0ub2JqZWN0VXJsKTtcbiAgICAgICAgICBuZXdDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0NhY2hlO1xuICAgIH0pO1xuXG4gICAgLy8gQWxzbyBjbGVhbnVwIEluZGV4ZWREQlxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBpbWFnZUNhY2hlREIuY2xlYW51cEV4cGlyZWQoY2FjaGVFeHBpcnlNcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNsZWFudXAgSW5kZXhlZERCOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtjYWNoZUV4cGlyeU1zXSk7XG5cbiAgY29uc3QgZ2V0SW1hZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAoaW1hZ2VJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgY2FjaGVkIHZlcnNpb24gdXNpbmcgcmVmIHRvIGF2b2lkIGRlcGVuZGVuY3lcbiAgICBjb25zdCBjYWNoZWRJdGVtID0gY2FjaGVSZWYuY3VycmVudC5nZXQoaW1hZ2VJZCk7XG4gICAgaWYgKGNhY2hlZEl0ZW0pIHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAobm93IC0gY2FjaGVkSXRlbS50aW1lc3RhbXAgPCBjYWNoZUV4cGlyeU1zKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRJdGVtLm9iamVjdFVybDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbW92ZSBleHBpcmVkIGl0ZW1cbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChjYWNoZWRJdGVtLm9iamVjdFVybCk7XG4gICAgICAgIHNldENhY2hlKHByZXYgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gbmV3IE1hcChwcmV2KTtcbiAgICAgICAgICBuZXdDYWNoZS5kZWxldGUoaW1hZ2VJZCk7XG4gICAgICAgICAgcmV0dXJuIG5ld0NhY2hlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFscmVhZHkgYSBwZW5kaW5nIHJlcXVlc3QgZm9yIHRoaXMgaW1hZ2VJZFxuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3RzLmN1cnJlbnQuZ2V0KGltYWdlSWQpO1xuICAgIGlmIChwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgcmVxdWVzdFxuICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcnN0LCB0cnkgdG8gZ2V0IGZyb20gSW5kZXhlZERCXG4gICAgICAgIGNvbnN0IGRiQ2FjaGVkSW1hZ2UgPSBhd2FpdCBpbWFnZUNhY2hlREIuZ2V0SW1hZ2UoaW1hZ2VJZCk7XG4gICAgICAgIGlmIChkYkNhY2hlZEltYWdlKSB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBpZiAobm93IC0gZGJDYWNoZWRJbWFnZS50aW1lc3RhbXAgPCBjYWNoZUV4cGlyeU1zKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgb2JqZWN0IFVSTCBmcm9tIEluZGV4ZWREQiBibG9iXG4gICAgICAgICAgICBjb25zdCBvYmplY3RVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGRiQ2FjaGVkSW1hZ2UuYmxvYik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCB0byBtZW1vcnkgY2FjaGVcbiAgICAgICAgICAgIHNldENhY2hlKHByZXYgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBNYXAocHJldik7XG4gICAgICAgICAgICAgIG5ld0NhY2hlLnNldChpbWFnZUlkLCB7XG4gICAgICAgICAgICAgICAgYmxvYjogZGJDYWNoZWRJbWFnZS5ibG9iLFxuICAgICAgICAgICAgICAgIG9iamVjdFVybCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRiQ2FjaGVkSW1hZ2UudGltZXN0YW1wXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FjaGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFVybDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGV4cGlyZWQgaXRlbSBmcm9tIEluZGV4ZWREQlxuICAgICAgICAgICAgYXdhaXQgaW1hZ2VDYWNoZURCLnJlbW92ZUltYWdlKGltYWdlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vdCBpbiBJbmRleGVkREIgb3IgZXhwaXJlZCwgZmV0Y2ggZnJvbSBBUElcbiAgICAgICAgY29uc29sZS5sb2coJ2ZldGNoaW5nIGltYWdlJywgaW1hZ2VJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwOC9wdWJsaWMvbWUvZWt5Yy9pbWFnZS8ke2ltYWdlSWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0FjY2VwdCc6ICdpbWFnZS8qJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBoZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAvLyBJZiBiYWNrZW5kIGlzIG5vdCBhdmFpbGFibGUsIHRyeSB0byBjcmVhdGUgYSBtb2NrIGltYWdlIGZvciB0ZXN0aW5nXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQmFja2VuZCByZXR1cm5lZCBlcnJvciwgY3JlYXRpbmcgbW9jayBpbWFnZSBmb3IgdGVzdGluZycpO1xuICAgICAgICAgICAgY29uc3QgbW9ja0Jsb2IgPSBhd2FpdCBjcmVhdGVNb2NrSW1hZ2UoNDAwLCAzMDAsIGBNb2NrOiAke2ltYWdlSWR9YCk7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG1vY2tCbG9iKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCB0byBtZW1vcnkgY2FjaGVcbiAgICAgICAgICAgIHNldENhY2hlKHByZXYgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBNYXAocHJldik7XG4gICAgICAgICAgICAgIG5ld0NhY2hlLnNldChpbWFnZUlkLCB7XG4gICAgICAgICAgICAgICAgYmxvYjogbW9ja0Jsb2IsXG4gICAgICAgICAgICAgICAgb2JqZWN0VXJsLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0NhY2hlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3RVcmw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgaW1hZ2U6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICBjb25zdCBvYmplY3RVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRvIG1lbW9yeSBjYWNoZVxuICAgICAgICBzZXRDYWNoZShwcmV2ID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBNYXAocHJldik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIG9sZGVzdCBpdGVtcyBpZiBjYWNoZSBpcyBmdWxsXG4gICAgICAgICAgaWYgKG5ld0NhY2hlLnNpemUgPj0gbWF4Q2FjaGVTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRlc3RLZXkgPSBuZXdDYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgb2xkZXN0SXRlbSA9IG5ld0NhY2hlLmdldChvbGRlc3RLZXkpO1xuICAgICAgICAgICAgaWYgKG9sZGVzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvbGRlc3RJdGVtLm9iamVjdFVybCk7XG4gICAgICAgICAgICAgIG5ld0NhY2hlLmRlbGV0ZShvbGRlc3RLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBuZXdDYWNoZS5zZXQoaW1hZ2VJZCwge1xuICAgICAgICAgICAgYmxvYixcbiAgICAgICAgICAgIG9iamVjdFVybCxcbiAgICAgICAgICAgIHRpbWVzdGFtcFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBuZXdDYWNoZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWxzbyBzYXZlIHRvIEluZGV4ZWREQiBmb3IgcGVyc2lzdGVuY2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBpbWFnZUNhY2hlREIuc2V0SW1hZ2UoaW1hZ2VJZCwgYmxvYiwgdGltZXN0YW1wKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzYXZlIHRvIEluZGV4ZWREQjonLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VXJsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICBwZW5kaW5nUmVxdWVzdHMuY3VycmVudC5kZWxldGUoaW1hZ2VJZCk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIFN0b3JlIHBlbmRpbmcgcmVxdWVzdFxuICAgIHBlbmRpbmdSZXF1ZXN0cy5jdXJyZW50LnNldChpbWFnZUlkLCByZXF1ZXN0UHJvbWlzZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcXVlc3RQcm9taXNlO1xuICB9LCBbY2FjaGVFeHBpcnlNcywgbWF4Q2FjaGVTaXplXSk7IC8vIFJlbW92ZWQgY2FjaGUgZnJvbSBkZXBlbmRlbmNpZXNcblxuICBjb25zdCBjbGVhckNhY2hlID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIGFsbCBvYmplY3QgVVJMc1xuICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShjYWNoZS52YWx1ZXMoKSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGl0ZW0ub2JqZWN0VXJsKTtcbiAgICB9XG4gICAgc2V0Q2FjaGUobmV3IE1hcCgpKTtcbiAgICAvLyBBbHNvIGNsZWFyIHBlbmRpbmcgcmVxdWVzdHNcbiAgICBwZW5kaW5nUmVxdWVzdHMuY3VycmVudC5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYXIgSW5kZXhlZERCXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGltYWdlQ2FjaGVEQi5jbGVhckFsbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBJbmRleGVkREI6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW10pOyAvLyBSZW1vdmVkIGNhY2hlIGRlcGVuZGVuY3lcblxuICBjb25zdCByZW1vdmVGcm9tQ2FjaGUgPSB1c2VDYWxsYmFjayhhc3luYyAoaW1hZ2VJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGNhY2hlLmdldChpbWFnZUlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChpdGVtLm9iamVjdFVybCk7XG4gICAgICBzZXRDYWNoZShwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgTWFwKHByZXYpO1xuICAgICAgICBuZXdDYWNoZS5kZWxldGUoaW1hZ2VJZCk7XG4gICAgICAgIHJldHVybiBuZXdDYWNoZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFsc28gcmVtb3ZlIGZyb20gSW5kZXhlZERCXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGltYWdlQ2FjaGVEQi5yZW1vdmVJbWFnZShpbWFnZUlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVtb3ZlIGZyb20gSW5kZXhlZERCOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gUmVtb3ZlZCBjYWNoZSBkZXBlbmRlbmN5XG5cbiAgY29uc3QgZ2V0Q2FjaGVTdGF0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGltYWdlQ2FjaGVEQi5nZXRDYWNoZVN0YXRzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCBjYWNoZSBzdGF0czonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBjb3VudDogMCwgdG90YWxTaXplOiAwIH07XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gQ2xlYW51cCBleHBpcmVkIGl0ZW1zIHBlcmlvZGljYWxseVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoY2xlYW51cEV4cGlyZWRJdGVtcywgNjAwMDApOyAvLyBDaGVjayBldmVyeSBtaW51dGVcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0sIFtjbGVhbnVwRXhwaXJlZEl0ZW1zXSk7XG5cbiAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyQ2FjaGUoKTtcbiAgICB9O1xuICB9LCBbY2xlYXJDYWNoZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPEltYWdlQ2FjaGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IGdldEltYWdlLCBjbGVhckNhY2hlLCByZW1vdmVGcm9tQ2FjaGUsIGdldENhY2hlU3RhdHMgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9JbWFnZUNhY2hlQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VJbWFnZUNhY2hlID0gKCk6IEltYWdlQ2FjaGVDb250ZXh0VHlwZSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEltYWdlQ2FjaGVDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VJbWFnZUNhY2hlIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gSW1hZ2VDYWNoZVByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59OyAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJpbWFnZUNhY2hlREIiLCJJbWFnZUNhY2hlQ29udGV4dCIsIkltYWdlQ2FjaGVQcm92aWRlciIsImNoaWxkcmVuIiwibWF4Q2FjaGVTaXplIiwiY2FjaGVFeHBpcnlNcyIsImNhY2hlIiwic2V0Q2FjaGUiLCJNYXAiLCJwZW5kaW5nUmVxdWVzdHMiLCJjYWNoZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJjbGVhbnVwRXhwaXJlZEl0ZW1zIiwibm93IiwiRGF0ZSIsInByZXZDYWNoZSIsIm5ld0NhY2hlIiwiZW50cmllcyIsIkFycmF5IiwiZnJvbSIsImtleSIsIml0ZW0iLCJ0aW1lc3RhbXAiLCJVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJvYmplY3RVcmwiLCJkZWxldGUiLCJjbGVhbnVwRXhwaXJlZCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXRJbWFnZSIsImltYWdlSWQiLCJjYWNoZWRJdGVtIiwiZ2V0IiwicHJldiIsInBlbmRpbmdSZXF1ZXN0IiwicmVxdWVzdFByb21pc2UiLCJkYkNhY2hlZEltYWdlIiwiY3JlYXRlT2JqZWN0VVJMIiwiYmxvYiIsInNldCIsInJlbW92ZUltYWdlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJvayIsIm1vY2tCbG9iIiwiY3JlYXRlTW9ja0ltYWdlIiwiRXJyb3IiLCJzaXplIiwib2xkZXN0S2V5Iiwia2V5cyIsIm5leHQiLCJ2YWx1ZSIsIm9sZGVzdEl0ZW0iLCJzZXRJbWFnZSIsImNsZWFyQ2FjaGUiLCJpdGVtcyIsInZhbHVlcyIsImNsZWFyIiwiY2xlYXJBbGwiLCJyZW1vdmVGcm9tQ2FjaGUiLCJnZXRDYWNoZVN0YXRzIiwiY291bnQiLCJ0b3RhbFNpemUiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIlByb3ZpZGVyIiwidXNlSW1hZ2VDYWNoZSIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./contexts/ImageCacheContext.tsx\n"));

/***/ })

});