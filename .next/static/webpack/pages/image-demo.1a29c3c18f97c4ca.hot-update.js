"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/image-demo",{

/***/ "./contexts/ImageCacheContext.tsx":
/*!****************************************!*\
  !*** ./contexts/ImageCacheContext.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImageCacheProvider: function() { return /* binding */ ImageCacheProvider; },\n/* harmony export */   useImageCache: function() { return /* binding */ useImageCache; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/indexedDB */ \"./utils/indexedDB.ts\");\n/* harmony import */ var _utils_mockImage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/mockImage */ \"./utils/mockImage.ts\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst ImageCacheContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst ImageCacheProvider = (param)=>{\n    let { children, maxCacheSize = 50, cacheExpiryMs = 5 * 60 * 1000 // 5 minutes\n     } = param;\n    _s();\n    const [cache, setCache] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Map());\n    const pendingRequests = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const cacheRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Keep cacheRef in sync with cache state\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        cacheRef.current = cache;\n    }, [\n        cache\n    ]);\n    const cleanupExpiredItems = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        const now = Date.now();\n        setCache((prevCache)=>{\n            const newCache = new Map(prevCache);\n            const entries = Array.from(newCache.entries());\n            for (const [key, item] of entries){\n                if (now - item.timestamp > cacheExpiryMs) {\n                    URL.revokeObjectURL(item.objectUrl);\n                    newCache.delete(key);\n                }\n            }\n            return newCache;\n        });\n        // Also cleanup IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].cleanupExpired(cacheExpiryMs);\n        } catch (error) {\n            console.warn(\"Failed to cleanup IndexedDB:\", error);\n        }\n    }, [\n        cacheExpiryMs\n    ]);\n    const getImage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (imageId)=>{\n        // Check if we have a cached version using ref to avoid dependency\n        const cachedItem = cacheRef.current.get(imageId);\n        if (cachedItem) {\n            const now = Date.now();\n            if (now - cachedItem.timestamp < cacheExpiryMs) {\n                return cachedItem.objectUrl;\n            } else {\n                // Remove expired item\n                URL.revokeObjectURL(cachedItem.objectUrl);\n                setCache((prev)=>{\n                    const newCache = new Map(prev);\n                    newCache.delete(imageId);\n                    return newCache;\n                });\n            }\n        }\n        // Check if there's already a pending request for this imageId\n        const pendingRequest = pendingRequests.current.get(imageId);\n        if (pendingRequest) {\n            return pendingRequest;\n        }\n        // Create new request\n        const requestPromise = (async ()=>{\n            try {\n                // First, try to get from IndexedDB\n                const dbCachedImage = await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getImage(imageId);\n                if (dbCachedImage) {\n                    const now = Date.now();\n                    if (now - dbCachedImage.timestamp < cacheExpiryMs) {\n                        // Create object URL from IndexedDB blob\n                        const objectUrl = URL.createObjectURL(dbCachedImage.blob);\n                        // Add to memory cache\n                        setCache((prev)=>{\n                            const newCache = new Map(prev);\n                            newCache.set(imageId, {\n                                blob: dbCachedImage.blob,\n                                objectUrl,\n                                timestamp: dbCachedImage.timestamp\n                            });\n                            return newCache;\n                        });\n                        return objectUrl;\n                    } else {\n                        // Remove expired item from IndexedDB\n                        await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].removeImage(imageId);\n                    }\n                }\n                // If not in IndexedDB or expired, fetch from API\n                console.log(\"fetching image\", imageId);\n                const requestTimestamp = Date.now();\n                // Retry logic for network issues\n                let lastError;\n                for(let attempt = 1; attempt <= 3; attempt++){\n                    try {\n                        console.log(\"Attempt \".concat(attempt, \" to fetch image\"));\n                        const response = await fetch(\"http://localhost:3008/public/me/ekyc/image/\".concat(imageId, \"?t=\").concat(requestTimestamp), {\n                            method: \"GET\",\n                            headers: {\n                                \"Accept\": \"image/*\",\n                                \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n                                \"Pragma\": \"no-cache\",\n                                \"Expires\": \"0\"\n                            }\n                        });\n                        console.log(\"Response status:\", response.status, response.statusText);\n                        console.log(\"Response headers:\", Object.fromEntries(response.headers.entries()));\n                        // Check if response is actually an image\n                        const contentType = response.headers.get(\"content-type\");\n                        console.log(\"Content-Type:\", contentType);\n                        // For streaming responses, Content-Type might not be available immediately\n                        // We'll validate the blob type instead\n                        if (contentType && !contentType.startsWith(\"image/\")) {\n                            console.warn(\"Response is not an image, content-type:\", contentType);\n                            // Try to read as text to see what we actually got\n                            const textResponse = await response.text();\n                            console.error(\"Response body (first 200 chars):\", textResponse.substring(0, 200));\n                            throw new Error(\"Server returned non-image content: \".concat(contentType));\n                        }\n                        if (!response.ok) {\n                            // If backend is not available, try to create a mock image for testing\n                            if (response.status === 404 || response.status === 400) {\n                                console.log(\"Backend returned error, creating mock image for testing\");\n                                const mockBlob = await (0,_utils_mockImage__WEBPACK_IMPORTED_MODULE_3__.createMockImage)(400, 300, \"Mock: \".concat(imageId));\n                                const objectUrl = URL.createObjectURL(mockBlob);\n                                const timestamp = Date.now();\n                                // Add to memory cache\n                                setCache((prev)=>{\n                                    const newCache = new Map(prev);\n                                    newCache.set(imageId, {\n                                        blob: mockBlob,\n                                        objectUrl,\n                                        timestamp\n                                    });\n                                    return newCache;\n                                });\n                                return objectUrl;\n                            }\n                            throw new Error(\"Failed to load image: \".concat(response.status, \" \").concat(response.statusText));\n                        }\n                        const blob = await response.blob();\n                        console.log(\"Blob created:\", {\n                            size: blob.size,\n                            type: blob.type\n                        });\n                        // Validate that we have a valid image blob\n                        if (!blob.type.startsWith(\"image/\")) {\n                            console.warn(\"Blob is not an image type:\", blob.type);\n                            throw new Error(\"Invalid image type: \".concat(blob.type));\n                        }\n                        if (blob.size === 0) {\n                            console.warn(\"Blob is empty\");\n                            throw new Error(\"Empty image data\");\n                        }\n                        // Test if blob can be read as image\n                        try {\n                            const testUrl = URL.createObjectURL(blob);\n                            const testImg = new Image();\n                            await new Promise((resolve, reject)=>{\n                                testImg.onload = ()=>{\n                                    console.log(\"Blob validation successful:\", {\n                                        width: testImg.width,\n                                        height: testImg.height\n                                    });\n                                    URL.revokeObjectURL(testUrl);\n                                    resolve(true);\n                                };\n                                testImg.onerror = ()=>{\n                                    console.error(\"Blob validation failed - not a valid image\");\n                                    URL.revokeObjectURL(testUrl);\n                                    reject(new Error(\"Blob is not a valid image\"));\n                                };\n                                testImg.src = testUrl;\n                            });\n                        } catch (error) {\n                            console.error(\"Blob validation error:\", error);\n                            throw new Error(\"Invalid image data from server\");\n                        }\n                        const objectUrl = URL.createObjectURL(blob);\n                        console.log(\"Object URL created:\", objectUrl);\n                        const timestamp = Date.now();\n                        // Add to memory cache\n                        setCache((prev)=>{\n                            const newCache = new Map(prev);\n                            // Remove oldest items if cache is full\n                            if (newCache.size >= maxCacheSize) {\n                                const oldestKey = newCache.keys().next().value;\n                                const oldestItem = newCache.get(oldestKey);\n                                if (oldestItem) {\n                                    URL.revokeObjectURL(oldestItem.objectUrl);\n                                    newCache.delete(oldestKey);\n                                }\n                            }\n                            newCache.set(imageId, {\n                                blob,\n                                objectUrl,\n                                timestamp\n                            });\n                            return newCache;\n                        });\n                        // Also save to IndexedDB for persistence\n                        try {\n                            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].setImage(imageId, blob, timestamp);\n                        } catch (error) {\n                            console.warn(\"Failed to save to IndexedDB:\", error);\n                        }\n                        return objectUrl;\n                    } catch (error) {\n                        lastError = error;\n                        console.warn(\"Attempt \".concat(attempt, \" failed:\"), error.message);\n                        if (attempt < 3) {\n                            // Wait before retry\n                            await new Promise((resolve)=>setTimeout(resolve, 1000 * attempt));\n                        }\n                    }\n                }\n                // All attempts failed\n                console.error(\"All fetch attempts failed:\", lastError);\n                throw lastError;\n            } finally{\n                // Remove from pending requests\n                pendingRequests.current.delete(imageId);\n            }\n        })();\n        // Store pending request\n        pendingRequests.current.set(imageId, requestPromise);\n        return requestPromise;\n    }, [\n        cacheExpiryMs,\n        maxCacheSize\n    ]); // Removed cache from dependencies\n    const clearCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        // Clean up all object URLs\n        const items = Array.from(cache.values());\n        for (const item of items){\n            URL.revokeObjectURL(item.objectUrl);\n        }\n        setCache(new Map());\n        // Also clear pending requests\n        pendingRequests.current.clear();\n        // Clear IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clearAll();\n        } catch (error) {\n            console.warn(\"Failed to clear IndexedDB:\", error);\n        }\n    }, []); // Removed cache dependency\n    const removeFromCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (imageId)=>{\n        const item = cache.get(imageId);\n        if (item) {\n            URL.revokeObjectURL(item.objectUrl);\n            setCache((prev)=>{\n                const newCache = new Map(prev);\n                newCache.delete(imageId);\n                return newCache;\n            });\n        }\n        // Also remove from IndexedDB\n        try {\n            await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].removeImage(imageId);\n        } catch (error) {\n            console.warn(\"Failed to remove from IndexedDB:\", error);\n        }\n    }, []); // Removed cache dependency\n    const getCacheStats = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        try {\n            return await _utils_indexedDB__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getCacheStats();\n        } catch (error) {\n            console.warn(\"Failed to get cache stats:\", error);\n            return {\n                count: 0,\n                totalSize: 0\n            };\n        }\n    }, []);\n    // Cleanup expired items periodically\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        const interval = setInterval(cleanupExpiredItems, 60000); // Check every minute\n        return ()=>clearInterval(interval);\n    }, [\n        cleanupExpiredItems\n    ]);\n    // Cleanup on unmount\n    react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(()=>{\n        return ()=>{\n            clearCache();\n        };\n    }, [\n        clearCache\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ImageCacheContext.Provider, {\n        value: {\n            getImage,\n            clearCache,\n            removeFromCache,\n            getCacheStats\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/nhuphuoc/Workspace/Tool/signinx/contexts/ImageCacheContext.tsx\",\n        lineNumber: 338,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ImageCacheProvider, \"WS6kNzq6/7ID0g6n+QFjWVIYGMw=\");\n_c = ImageCacheProvider;\nconst useImageCache = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ImageCacheContext);\n    if (!context) {\n        throw new Error(\"useImageCache must be used within an ImageCacheProvider\");\n    }\n    return context;\n};\n_s1(useImageCache, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ImageCacheProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZixxQkFDRSw4REFBQ3BGLGtCQUFrQmdHLFFBQVE7UUFBQ2pCLE9BQU87WUFBRWhEO1lBQVVxRDtZQUFZSztZQUFpQkM7UUFBYztrQkFDdkZ4Rjs7Ozs7O0FBR1AsRUFBRTtHQTVUV0Q7S0FBQUE7QUE4VE4sTUFBTWdHLGdCQUFnQjs7SUFDM0IsTUFBTUMsVUFBVXhHLGlEQUFVQSxDQUFDTTtJQUMzQixJQUFJLENBQUNrRyxTQUFTO1FBQ1osTUFBTSxJQUFJdEMsTUFBTTtJQUNsQjtJQUNBLE9BQU9zQztBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dHMvSW1hZ2VDYWNoZUNvbnRleHQudHN4P2JlZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGltYWdlQ2FjaGVEQiBmcm9tICcuLi91dGlscy9pbmRleGVkREInO1xuaW1wb3J0IHsgY3JlYXRlTW9ja0ltYWdlIH0gZnJvbSAnLi4vdXRpbHMvbW9ja0ltYWdlJztcblxuaW50ZXJmYWNlIEltYWdlQ2FjaGVJdGVtIHtcbiAgYmxvYjogQmxvYjtcbiAgb2JqZWN0VXJsOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgSW1hZ2VDYWNoZUNvbnRleHRUeXBlIHtcbiAgZ2V0SW1hZ2U6IChpbWFnZUlkOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPjtcbiAgY2xlYXJDYWNoZTogKCkgPT4gdm9pZDtcbiAgcmVtb3ZlRnJvbUNhY2hlOiAoaW1hZ2VJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBnZXRDYWNoZVN0YXRzOiAoKSA9PiBQcm9taXNlPHsgY291bnQ6IG51bWJlcjsgdG90YWxTaXplOiBudW1iZXIgfT47XG59XG5cbmNvbnN0IEltYWdlQ2FjaGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxJbWFnZUNhY2hlQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcblxuaW50ZXJmYWNlIEltYWdlQ2FjaGVQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbWF4Q2FjaGVTaXplPzogbnVtYmVyO1xuICBjYWNoZUV4cGlyeU1zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgSW1hZ2VDYWNoZVByb3ZpZGVyOiBSZWFjdC5GQzxJbWFnZUNhY2hlUHJvdmlkZXJQcm9wcz4gPSAoe1xuICBjaGlsZHJlbixcbiAgbWF4Q2FjaGVTaXplID0gNTAsXG4gIGNhY2hlRXhwaXJ5TXMgPSA1ICogNjAgKiAxMDAwIC8vIDUgbWludXRlc1xufSkgPT4ge1xuICBjb25zdCBbY2FjaGUsIHNldENhY2hlXSA9IHVzZVN0YXRlPE1hcDxzdHJpbmcsIEltYWdlQ2FjaGVJdGVtPj4obmV3IE1hcCgpKTtcbiAgY29uc3QgcGVuZGluZ1JlcXVlc3RzID0gdXNlUmVmPE1hcDxzdHJpbmcsIFByb21pc2U8c3RyaW5nPj4+KG5ldyBNYXAoKSk7XG4gIGNvbnN0IGNhY2hlUmVmID0gdXNlUmVmPE1hcDxzdHJpbmcsIEltYWdlQ2FjaGVJdGVtPj4obmV3IE1hcCgpKTtcblxuICAvLyBLZWVwIGNhY2hlUmVmIGluIHN5bmMgd2l0aCBjYWNoZSBzdGF0ZVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNhY2hlUmVmLmN1cnJlbnQgPSBjYWNoZTtcbiAgfSwgW2NhY2hlXSk7XG5cbiAgY29uc3QgY2xlYW51cEV4cGlyZWRJdGVtcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIHNldENhY2hlKHByZXZDYWNoZSA9PiB7XG4gICAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBNYXAocHJldkNhY2hlKTtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKG5ld0NhY2hlLmVudHJpZXMoKSk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIGl0ZW1dIG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKG5vdyAtIGl0ZW0udGltZXN0YW1wID4gY2FjaGVFeHBpcnlNcykge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaXRlbS5vYmplY3RVcmwpO1xuICAgICAgICAgIG5ld0NhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3Q2FjaGU7XG4gICAgfSk7XG5cbiAgICAvLyBBbHNvIGNsZWFudXAgSW5kZXhlZERCXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGltYWdlQ2FjaGVEQi5jbGVhbnVwRXhwaXJlZChjYWNoZUV4cGlyeU1zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY2xlYW51cCBJbmRleGVkREI6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW2NhY2hlRXhwaXJ5TXNdKTtcblxuICBjb25zdCBnZXRJbWFnZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChpbWFnZUlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZWQgdmVyc2lvbiB1c2luZyByZWYgdG8gYXZvaWQgZGVwZW5kZW5jeVxuICAgIGNvbnN0IGNhY2hlZEl0ZW0gPSBjYWNoZVJlZi5jdXJyZW50LmdldChpbWFnZUlkKTtcbiAgICBpZiAoY2FjaGVkSXRlbSkge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmIChub3cgLSBjYWNoZWRJdGVtLnRpbWVzdGFtcCA8IGNhY2hlRXhwaXJ5TXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEl0ZW0ub2JqZWN0VXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV4cGlyZWQgaXRlbVxuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGNhY2hlZEl0ZW0ub2JqZWN0VXJsKTtcbiAgICAgICAgc2V0Q2FjaGUocHJldiA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgTWFwKHByZXYpO1xuICAgICAgICAgIG5ld0NhY2hlLmRlbGV0ZShpbWFnZUlkKTtcbiAgICAgICAgICByZXR1cm4gbmV3Q2FjaGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYWxyZWFkeSBhIHBlbmRpbmcgcmVxdWVzdCBmb3IgdGhpcyBpbWFnZUlkXG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSBwZW5kaW5nUmVxdWVzdHMuY3VycmVudC5nZXQoaW1hZ2VJZCk7XG4gICAgaWYgKHBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3Q7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldyByZXF1ZXN0XG4gICAgY29uc3QgcmVxdWVzdFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyc3QsIHRyeSB0byBnZXQgZnJvbSBJbmRleGVkREJcbiAgICAgICAgY29uc3QgZGJDYWNoZWRJbWFnZSA9IGF3YWl0IGltYWdlQ2FjaGVEQi5nZXRJbWFnZShpbWFnZUlkKTtcbiAgICAgICAgaWYgKGRiQ2FjaGVkSW1hZ2UpIHtcbiAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGlmIChub3cgLSBkYkNhY2hlZEltYWdlLnRpbWVzdGFtcCA8IGNhY2hlRXhwaXJ5TXMpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBvYmplY3QgVVJMIGZyb20gSW5kZXhlZERCIGJsb2JcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZGJDYWNoZWRJbWFnZS5ibG9iKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHRvIG1lbW9yeSBjYWNoZVxuICAgICAgICAgICAgc2V0Q2FjaGUocHJldiA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gbmV3IE1hcChwcmV2KTtcbiAgICAgICAgICAgICAgbmV3Q2FjaGUuc2V0KGltYWdlSWQsIHtcbiAgICAgICAgICAgICAgICBibG9iOiBkYkNhY2hlZEltYWdlLmJsb2IsXG4gICAgICAgICAgICAgICAgb2JqZWN0VXJsLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZGJDYWNoZWRJbWFnZS50aW1lc3RhbXBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdDYWNoZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0VXJsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZXhwaXJlZCBpdGVtIGZyb20gSW5kZXhlZERCXG4gICAgICAgICAgICBhd2FpdCBpbWFnZUNhY2hlREIucmVtb3ZlSW1hZ2UoaW1hZ2VJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm90IGluIEluZGV4ZWREQiBvciBleHBpcmVkLCBmZXRjaCBmcm9tIEFQSVxuICAgICAgICBjb25zb2xlLmxvZygnZmV0Y2hpbmcgaW1hZ2UnLCBpbWFnZUlkKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXRyeSBsb2dpYyBmb3IgbmV0d29yayBpc3N1ZXNcbiAgICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gMzsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0ICR7YXR0ZW1wdH0gdG8gZmV0Y2ggaW1hZ2VgKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwOC9wdWJsaWMvbWUvZWt5Yy9pbWFnZS8ke2ltYWdlSWR9P3Q9JHtyZXF1ZXN0VGltZXN0YW1wfWAsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnaW1hZ2UvKicsXG4gICAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUsIG5vLXN0b3JlLCBtdXN0LXJldmFsaWRhdGUnLFxuICAgICAgICAgICAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICAgICdFeHBpcmVzJzogJzAnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGhlYWRlcnM6JywgT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGlzIGFjdHVhbGx5IGFuIGltYWdlXG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250ZW50LVR5cGU6JywgY29udGVudFR5cGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGb3Igc3RyZWFtaW5nIHJlc3BvbnNlcywgQ29udGVudC1UeXBlIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIFdlJ2xsIHZhbGlkYXRlIHRoZSBibG9iIHR5cGUgaW5zdGVhZFxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmICFjb250ZW50VHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Jlc3BvbnNlIGlzIG5vdCBhbiBpbWFnZSwgY29udGVudC10eXBlOicsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlYWQgYXMgdGV4dCB0byBzZWUgd2hhdCB3ZSBhY3R1YWxseSBnb3RcbiAgICAgICAgICAgICAgY29uc3QgdGV4dFJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdSZXNwb25zZSBib2R5IChmaXJzdCAyMDAgY2hhcnMpOicsIHRleHRSZXNwb25zZS5zdWJzdHJpbmcoMCwgMjAwKSk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJldHVybmVkIG5vbi1pbWFnZSBjb250ZW50OiAke2NvbnRlbnRUeXBlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIC8vIElmIGJhY2tlbmQgaXMgbm90IGF2YWlsYWJsZSwgdHJ5IHRvIGNyZWF0ZSBhIG1vY2sgaW1hZ2UgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0IHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JhY2tlbmQgcmV0dXJuZWQgZXJyb3IsIGNyZWF0aW5nIG1vY2sgaW1hZ2UgZm9yIHRlc3RpbmcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2NrQmxvYiA9IGF3YWl0IGNyZWF0ZU1vY2tJbWFnZSg0MDAsIDMwMCwgYE1vY2s6ICR7aW1hZ2VJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG1vY2tCbG9iKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBtZW1vcnkgY2FjaGVcbiAgICAgICAgICAgICAgICBzZXRDYWNoZShwcmV2ID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gbmV3IE1hcChwcmV2KTtcbiAgICAgICAgICAgICAgICAgIG5ld0NhY2hlLnNldChpbWFnZUlkLCB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2I6IG1vY2tCbG9iLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RVcmwsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FjaGU7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0VXJsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgaW1hZ2U6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQmxvYiBjcmVhdGVkOicsIHtcbiAgICAgICAgICAgICAgc2l6ZTogYmxvYi5zaXplLFxuICAgICAgICAgICAgICB0eXBlOiBibG9iLnR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGhhdmUgYSB2YWxpZCBpbWFnZSBibG9iXG4gICAgICAgICAgICBpZiAoIWJsb2IudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Jsb2IgaXMgbm90IGFuIGltYWdlIHR5cGU6JywgYmxvYi50eXBlKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGltYWdlIHR5cGU6ICR7YmxvYi50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoYmxvYi5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignQmxvYiBpcyBlbXB0eScpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IGltYWdlIGRhdGEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGVzdCBpZiBibG9iIGNhbiBiZSByZWFkIGFzIGltYWdlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB0ZXN0VXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgY29uc3QgdGVzdEltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGVzdEltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmxvYiB2YWxpZGF0aW9uIHN1Y2Nlc3NmdWw6Jywge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGVzdEltZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0ZXN0SW1nLmhlaWdodFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRlc3RVcmwpO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRlc3RJbWcub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Jsb2IgdmFsaWRhdGlvbiBmYWlsZWQgLSBub3QgYSB2YWxpZCBpbWFnZScpO1xuICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0ZXN0VXJsKTtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Jsb2IgaXMgbm90IGEgdmFsaWQgaW1hZ2UnKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0ZXN0SW1nLnNyYyA9IHRlc3RVcmw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQmxvYiB2YWxpZGF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGltYWdlIGRhdGEgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0VXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPYmplY3QgVVJMIGNyZWF0ZWQ6Jywgb2JqZWN0VXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCB0byBtZW1vcnkgY2FjaGVcbiAgICAgICAgICAgIHNldENhY2hlKHByZXYgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IG5ldyBNYXAocHJldik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkZXN0IGl0ZW1zIGlmIGNhY2hlIGlzIGZ1bGxcbiAgICAgICAgICAgICAgaWYgKG5ld0NhY2hlLnNpemUgPj0gbWF4Q2FjaGVTaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkZXN0S2V5ID0gbmV3Q2FjaGUua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRlc3RJdGVtID0gbmV3Q2FjaGUuZ2V0KG9sZGVzdEtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG9sZGVzdEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2xkZXN0SXRlbS5vYmplY3RVcmwpO1xuICAgICAgICAgICAgICAgICAgbmV3Q2FjaGUuZGVsZXRlKG9sZGVzdEtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBuZXdDYWNoZS5zZXQoaW1hZ2VJZCwge1xuICAgICAgICAgICAgICAgIGJsb2IsXG4gICAgICAgICAgICAgICAgb2JqZWN0VXJsLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiBuZXdDYWNoZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBbHNvIHNhdmUgdG8gSW5kZXhlZERCIGZvciBwZXJzaXN0ZW5jZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgaW1hZ2VDYWNoZURCLnNldEltYWdlKGltYWdlSWQsIGJsb2IsIHRpbWVzdGFtcCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBzYXZlIHRvIEluZGV4ZWREQjonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3RVcmw7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBdHRlbXB0ICR7YXR0ZW1wdH0gZmFpbGVkOmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA8IDMpIHtcbiAgICAgICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAgKiBhdHRlbXB0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBbGwgYXR0ZW1wdHMgZmFpbGVkXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FsbCBmZXRjaCBhdHRlbXB0cyBmYWlsZWQ6JywgbGFzdEVycm9yKTtcbiAgICAgICAgdGhyb3cgbGFzdEVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gcGVuZGluZyByZXF1ZXN0c1xuICAgICAgICBwZW5kaW5nUmVxdWVzdHMuY3VycmVudC5kZWxldGUoaW1hZ2VJZCk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIFN0b3JlIHBlbmRpbmcgcmVxdWVzdFxuICAgIHBlbmRpbmdSZXF1ZXN0cy5jdXJyZW50LnNldChpbWFnZUlkLCByZXF1ZXN0UHJvbWlzZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcXVlc3RQcm9taXNlO1xuICB9LCBbY2FjaGVFeHBpcnlNcywgbWF4Q2FjaGVTaXplXSk7IC8vIFJlbW92ZWQgY2FjaGUgZnJvbSBkZXBlbmRlbmNpZXNcblxuICBjb25zdCBjbGVhckNhY2hlID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIC8vIENsZWFuIHVwIGFsbCBvYmplY3QgVVJMc1xuICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShjYWNoZS52YWx1ZXMoKSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGl0ZW0ub2JqZWN0VXJsKTtcbiAgICB9XG4gICAgc2V0Q2FjaGUobmV3IE1hcCgpKTtcbiAgICAvLyBBbHNvIGNsZWFyIHBlbmRpbmcgcmVxdWVzdHNcbiAgICBwZW5kaW5nUmVxdWVzdHMuY3VycmVudC5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYXIgSW5kZXhlZERCXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGltYWdlQ2FjaGVEQi5jbGVhckFsbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBJbmRleGVkREI6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW10pOyAvLyBSZW1vdmVkIGNhY2hlIGRlcGVuZGVuY3lcblxuICBjb25zdCByZW1vdmVGcm9tQ2FjaGUgPSB1c2VDYWxsYmFjayhhc3luYyAoaW1hZ2VJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGNhY2hlLmdldChpbWFnZUlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChpdGVtLm9iamVjdFVybCk7XG4gICAgICBzZXRDYWNoZShwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSBuZXcgTWFwKHByZXYpO1xuICAgICAgICBuZXdDYWNoZS5kZWxldGUoaW1hZ2VJZCk7XG4gICAgICAgIHJldHVybiBuZXdDYWNoZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFsc28gcmVtb3ZlIGZyb20gSW5kZXhlZERCXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGltYWdlQ2FjaGVEQi5yZW1vdmVJbWFnZShpbWFnZUlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVtb3ZlIGZyb20gSW5kZXhlZERCOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gUmVtb3ZlZCBjYWNoZSBkZXBlbmRlbmN5XG5cbiAgY29uc3QgZ2V0Q2FjaGVTdGF0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGltYWdlQ2FjaGVEQi5nZXRDYWNoZVN0YXRzKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCBjYWNoZSBzdGF0czonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBjb3VudDogMCwgdG90YWxTaXplOiAwIH07XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gQ2xlYW51cCBleHBpcmVkIGl0ZW1zIHBlcmlvZGljYWxseVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoY2xlYW51cEV4cGlyZWRJdGVtcywgNjAwMDApOyAvLyBDaGVjayBldmVyeSBtaW51dGVcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0sIFtjbGVhbnVwRXhwaXJlZEl0ZW1zXSk7XG5cbiAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyQ2FjaGUoKTtcbiAgICB9O1xuICB9LCBbY2xlYXJDYWNoZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPEltYWdlQ2FjaGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IGdldEltYWdlLCBjbGVhckNhY2hlLCByZW1vdmVGcm9tQ2FjaGUsIGdldENhY2hlU3RhdHMgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9JbWFnZUNhY2hlQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VJbWFnZUNhY2hlID0gKCk6IEltYWdlQ2FjaGVDb250ZXh0VHlwZSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEltYWdlQ2FjaGVDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VJbWFnZUNhY2hlIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gSW1hZ2VDYWNoZVByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59OyAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJpbWFnZUNhY2hlREIiLCJjcmVhdGVNb2NrSW1hZ2UiLCJJbWFnZUNhY2hlQ29udGV4dCIsIkltYWdlQ2FjaGVQcm92aWRlciIsImNoaWxkcmVuIiwibWF4Q2FjaGVTaXplIiwiY2FjaGVFeHBpcnlNcyIsImNhY2hlIiwic2V0Q2FjaGUiLCJNYXAiLCJwZW5kaW5nUmVxdWVzdHMiLCJjYWNoZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJjbGVhbnVwRXhwaXJlZEl0ZW1zIiwibm93IiwiRGF0ZSIsInByZXZDYWNoZSIsIm5ld0NhY2hlIiwiZW50cmllcyIsIkFycmF5IiwiZnJvbSIsImtleSIsIml0ZW0iLCJ0aW1lc3RhbXAiLCJVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJvYmplY3RVcmwiLCJkZWxldGUiLCJjbGVhbnVwRXhwaXJlZCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXRJbWFnZSIsImltYWdlSWQiLCJjYWNoZWRJdGVtIiwiZ2V0IiwicHJldiIsInBlbmRpbmdSZXF1ZXN0IiwicmVxdWVzdFByb21pc2UiLCJkYkNhY2hlZEltYWdlIiwiY3JlYXRlT2JqZWN0VVJMIiwiYmxvYiIsInNldCIsInJlbW92ZUltYWdlIiwibG9nIiwicmVxdWVzdFRpbWVzdGFtcCIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImNvbnRlbnRUeXBlIiwic3RhcnRzV2l0aCIsInRleHRSZXNwb25zZSIsInRleHQiLCJzdWJzdHJpbmciLCJFcnJvciIsIm9rIiwibW9ja0Jsb2IiLCJzaXplIiwidHlwZSIsInRlc3RVcmwiLCJ0ZXN0SW1nIiwiSW1hZ2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9ubG9hZCIsIndpZHRoIiwiaGVpZ2h0Iiwib25lcnJvciIsInNyYyIsIm9sZGVzdEtleSIsImtleXMiLCJuZXh0IiwidmFsdWUiLCJvbGRlc3RJdGVtIiwic2V0SW1hZ2UiLCJtZXNzYWdlIiwic2V0VGltZW91dCIsImNsZWFyQ2FjaGUiLCJpdGVtcyIsInZhbHVlcyIsImNsZWFyIiwiY2xlYXJBbGwiLCJyZW1vdmVGcm9tQ2FjaGUiLCJnZXRDYWNoZVN0YXRzIiwiY291bnQiLCJ0b3RhbFNpemUiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIlByb3ZpZGVyIiwidXNlSW1hZ2VDYWNoZSIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./contexts/ImageCacheContext.tsx\n"));

/***/ })

});